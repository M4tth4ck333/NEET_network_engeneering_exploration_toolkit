<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEET_network_engeneering_exploration_toolkit</title>
    <!-- Tailwind CSS f√ºr ein modernes, konsistentes Design -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font f√ºr eine klare und moderne Typografie -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Grundlegende Stile, die die Philosophie widerspiegeln */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0a0a0a; /* Tiefer, dunkler Hintergrund f√ºr den Null-Vektorraum */
            color: #00ff00; /* Neon-Gr√ºn f√ºr digitale Energie und Fluss */
            margin: 0;
            padding: 0;
            overflow: hidden; /* Verhindert Scrollbalken, da der vCanvas den gesamten Raum einnimmt */
        }
        /* Der Root-Container f√ºr Ihre React/O3DE-Anwendung */
        #root {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column; /* F√ºr vertikale Anordnung von Text und Canvas */
            justify-content: center;
            align-items: center;
            /* Hier k√∂nnte ein subtiler Gl√ºheffekt oder ein Hintergrundmuster sein,
               das den unmanifestierten Potenzialraum des NullumCorpus andeutet */
        }
        #loadingCanvas {
            border-radius: 50%; /* F√ºr einen runden Effekt */
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5); /* Gl√ºheffekt */
        }
    </style>
</head>
<body>
    <!-- Der Root-Punkt, an dem Ihre React-Anwendung (das "DIY.metavisualyzerkit") eingeh√§ngt wird -->
    <div id="root">
        <!-- Ein Ladehinweis, w√§hrend das System manifestiert wird -->
        <p class="text-xl text-cyan-400 animate-pulse mb-4">
            üåå Initialisiere DIY.metavisualyzerkit...
        </p>
        <!-- Canvas f√ºr die animierte Spirale -->
        <canvas id="loadingCanvas" width="200" height="200" class="border border-cyan-500"></canvas>
    </div>
    
    <!-- Hier wird das JavaScript f√ºr die Ladeanimation geladen -->
    <script>
        const canvas = document.getElementById('loadingCanvas');
        const ctx = canvas.getContext('2d');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const initialNumPoints = 5; // Startanzahl der Punkte
        const finalNumPoints = 66; // Endanzahl der Punkte (jetzt 66)
        const initialMaxRadius = 40; // Initialer Radius der Spirale
        const finalMaxRadius = initialMaxRadius * 1.5; // Endradius (1.5 mal gr√∂√üer)
        const rotations = 3; // Anzahl der Rotationen der Spirale (jetzt 3)

        let spiralPoints = [];
        let currentPointIndex = 0;
        let animationFrameId;
        let loadingProgress = 0; // Simulierter Ladestand von 0.0 bis 1.0
        const loadingSpeed = 0.005; // Geschwindigkeit, mit der der Ladestand steigt

        const colors = ['#FF0000', '#00FF00', '#0000FF']; // RGB Farben

        // Funktion zur Berechnung der Spiralpunkte basierend auf dem Ladestand
        function calculateSpiralPoints(progress) {
            const currentNumPoints = initialNumPoints + (finalNumPoints - initialNumPoints) * progress;
            const currentMaxRadius = initialMaxRadius + (finalMaxRadius - initialMaxRadius) * progress;

            spiralPoints = [];
            for (let i = 0; i <= currentNumPoints; i++) {
                const angle = (i / currentNumPoints) * (Math.PI * 2 * rotations);
                const radius = (i / currentNumPoints) * currentMaxRadius;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                spiralPoints.push({ x, y });
            }
        }

        // Funktion zum Zeichnen der Animation
        function animateSpiral() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Canvas leeren

            // Ladestand aktualisieren
            loadingProgress += loadingSpeed;
            if (loadingProgress > 1.0) {
                loadingProgress = 1.0; // Sicherstellen, dass es nicht √ºber 1.0 geht
                // Optional: Hier k√∂nnte man die Animation stoppen oder in einen Endzustand √ºbergehen
            }

            // Spiralpunkte neu berechnen, da sich Gr√∂√üe und Dichte √§ndern
            calculateSpiralPoints(loadingProgress);

            // Pfad der Spirale zeichnen
            ctx.beginPath();
            if (spiralPoints.length > 0) {
                ctx.moveTo(spiralPoints[0].x, spiralPoints[0].y);
                for (let i = 1; i < spiralPoints.length; i++) {
                    ctx.lineTo(spiralPoints[i].x, spiralPoints[i].y);
                }
            }
            ctx.strokeStyle = `rgba(0, 255, 255, ${0.3 + 0.5 * loadingProgress})`; // Hellblau, Transparenz nimmt zu
            ctx.lineWidth = 1 + loadingProgress; // Dicke nimmt leicht zu
            ctx.stroke();

            // Den animierten Punkt zeichnen
            // currentPointIndex muss relativ zur aktuellen Anzahl der Punkte sein
            if (spiralPoints.length > 0) {
                const currentPos = spiralPoints[currentPointIndex % spiralPoints.length];
                const colorIndex = currentPointIndex % colors.length; // RGB-Farbenzyklus
                ctx.beginPath();
                ctx.arc(currentPos.x, currentPos.y, 5, 0, Math.PI * 2); // Punktgr√∂√üe 5
                ctx.fillStyle = colors[colorIndex]; // Farbe aus dem RGB-Array
                ctx.fill();
            }
            
            currentPointIndex = (currentPointIndex + 1); // N√§chster Punkt im Kreis

            animationFrameId = requestAnimationFrame(animateSpiral);
        }

        // Animation starten, sobald das DOM geladen ist
        document.addEventListener('DOMContentLoaded', () => {
            animateSpiral(); // Startet die Animation und die Berechnung
        });

        // Optional: Animation stoppen, wenn die Hauptanwendung geladen ist
        // Dies m√ºsste √ºber eine globale Variable oder ein Event in main.jsx gesteuert werden.
        // Beispiel: window.stopLoadingAnimation = () => cancelAnimationFrame(animationFrameId);
    </script> 
    
    <!-- Hier wird Ihr Haupt-JavaScript/TypeScript-Bundle geladen,
         das Ihre React-Anwendung und die O3DE-Initialisierung startet. -->
    <script type="module" src="/src/main.jsx"></script> 
</body>
</html>
